{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface {\n  uint256 public constant override version = 0;\n\n  uint8 public override decimals;\n  int256 public override latestAnswer;\n  uint256 public override latestTimestamp;\n  uint256 public override latestRound;\n\n  mapping(uint256 => int256) public override getAnswer;\n  mapping(uint256 => uint256) public override getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(uint8 _decimals, int256 _initialAnswer) {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(int256 _answer) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description() external pure override returns (string memory) {\n    return \"v0.8/tests/MockV3Aggregator.sol\";\n  }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/Dex/LiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"../Router/InterfaceBridge.sol\";\nimport \"./PoolTracker.sol\";\n\nerror assetNotCorrect();\nerror notEnoughTokens();\nerror notEnoughGas();\nerror notEnoughTimePassed();\nerror initialLiquidityAlreadyProvided();\nerror addressNotCorrect();\nerror amountTooBig();\nerror needToCallExistingFunction();\n\n/**\n * @title LiquidityPool\n * @dev A decentralized liquidity pool contract for swapping assets and providing liquidity.\n */\ncontract LiquidityPool is IZKBridgeReceiver {\n    // Events\n    event priceChanged(address _asset, uint256 price);\n    event liquidityAdded(\n        address indexed _address,\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    );\n    event liquidityRemoved(\n        address indexed _address,\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    );\n    event yieldFarmed(address indexed _address, uint256 _amount);\n\n    // Token Addresses\n    address public assetOneAddress;\n    address public assetTwoAddress;\n\n    // Liquidity and Yield (fees)\n    uint256 public initialLiquidity;\n    uint256 public liquidity;\n    uint256 public yield;\n    uint256 public swapFee = 1000000000000000;\n    address public owner;\n\n    // Reentrancy Guard\n    bool internal locked;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /**\n     * @dev Modifier to restrict functions only to the owner.\n     */\n    modifier onlyOwner() {\n        msg.sender == owner;\n        _;\n    }\n\n    /**\n     * @dev Constructor to initialize the liquidity pool with two asset addresses.\n     * @param _assetOneAddress The address of the first asset.\n     * @param _assetTwoAddress The address of the second asset.\n     */\n    constructor(address _assetOneAddress, address _assetTwoAddress) {\n        assetOneAddress = _assetOneAddress;\n        assetTwoAddress = _assetTwoAddress;\n        owner = msg.sender;\n        swapFee = 1000000000000000; // 0.001 ether\n    }\n\n    /**\n     * @dev Function to change the swap fee. Only callable by the owner.\n     * @param newSwapFee The new swap fee to set.\n     */\n    function changeSwapFee(uint256 newSwapFee) public onlyOwner {\n        swapFee = newSwapFee;\n    }\n\n    // TRACK THE LP TOKEN QUANTITY, INITIAL LIQUIDITY\n    mapping(address => uint256) public lpTokenQuantity;\n\n    /**\n     * @dev Function to add initial liquidity to the pool. Only callable by the owner.\n     * @dev Needs the ERC-20 approval for transferFrom.\n     * @param _assetOneAmount The amount of the first asset to add.\n     * @param _assetTwoAmount The amount of the second asset to add.\n     */\n    function addInitialLiquidity(\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    ) public onlyOwner {\n        if (initialLiquidityProvidedTime[owner] > 0) {\n            revert initialLiquidityAlreadyProvided();\n        }\n        initialLiquidityProvidedTime[msg.sender] = block.timestamp;\n\n        // SENDS THE TOKENS TO THE LIQUIDITY POOL\n        IERC20(assetOneAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _assetOneAmount\n        );\n        IERC20(assetTwoAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _assetTwoAmount\n        );\n\n        // SET THE INITIAL LIQUIDITY\n        initialLiquidity = _assetOneAmount * _assetTwoAmount;\n        liquidity = initialLiquidity;\n\n        // GIVE LP TOKENS TO THE INITIAL LIQUIDITY PROVIDER\n        lpTokenQuantity[msg.sender] = initialLiquidity;\n\n        // EMIT EVENT\n        emit liquidityAdded(msg.sender, _assetOneAmount, _assetTwoAmount);\n    }\n\n    /**\n     * @dev Function to add additional liquidity to the pool.\n     * @dev Needs the ERC-20 approval for transferFrom.\n     * @param _asset The address of the first asset.\n     * @param _secondAsset The address of the second asset.\n     * @param _amount The amount of the first asset to add.\n     */\n    function addLiquidity(\n        address _asset,\n        address _secondAsset,\n        uint256 _amount\n    ) public noReentrancy {\n        // SET THE RATIO, require token balance provided in ERC20, reverted if too low\n        IERC20(_secondAsset).transferFrom(\n            msg.sender,\n            address(this),\n            amountOfOppositeTokenNeeded(_asset, _amount)\n        );\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n\n        // give lp tokens to new liquidity provider\n        lpTokenQuantity[msg.sender] += (_amount *\n            amountOfOppositeTokenNeeded(_asset, _amount));\n        liquidity += (_amount * amountOfOppositeTokenNeeded(_asset, _amount));\n\n        // EMIT EVENT\n        emit liquidityAdded(\n            msg.sender,\n            amountOfOppositeTokenNeeded(_asset, _amount),\n            _amount\n        );\n    }\n\n    /**\n     * @dev Function to remove liquidity from the pool.\n     * @param _amount The percentage of liquidity to withdraw(10 -> 10%).\n     */\n    function removeLiquidity(uint256 _amount) public noReentrancy {\n        uint256 userLpTokens = lpTokenQuantity[msg.sender];\n        uint256 percentageOfLiquidity = (userLpTokens * 1 ether) / liquidity; // How much user owns out of all Liquidity in percentage\n        uint256 percentageOfUserLiquidity = (percentageOfLiquidity * _amount) /\n            100; // How much out of their liquidity they want to withdraw in percentage\n        uint256 resultAssetOne = (percentageOfUserLiquidity * getAssetOne()) /\n            1 ether;\n        uint256 resultAssetTwo = (percentageOfUserLiquidity * getAssetTwo()) /\n            1 ether;\n        // condition for owner, because of the initial liquidity timer\n        if (\n            (msg.sender == owner) &&\n            (isTimeInitialLiquidity() == false) &&\n            //the owner has the ability to withdraw liquidity if it wasn't part of initial liquidity\n            ((lpTokenQuantity[msg.sender] - (resultAssetOne * resultAssetTwo)) <\n                initialLiquidity)\n        ) {\n            revert notEnoughTokens();\n        }\n        // check balance if it is high enough to continue, can't get reverted at transfer, it should have the balance but just in case\n        if (\n            IERC20(assetOneAddress).balanceOf(address(this)) < resultAssetOne ||\n            IERC20(assetTwoAddress).balanceOf(address(this)) < resultAssetTwo\n        ) {\n            revert notEnoughTokens();\n        }\n        IERC20(assetOneAddress).transfer(msg.sender, resultAssetOne);\n        IERC20(assetTwoAddress).transfer(msg.sender, resultAssetTwo);\n\n        // EMIT EVENT\n        emit liquidityRemoved(msg.sender, resultAssetOne, resultAssetTwo);\n    }\n\n    /**\n     * @dev Function to sell the first asset and receive the second asset.\n     * @param _amount The amount of the first asset to sell.\n     */\n    function sellAssetOne(uint256 _amount) public payable noReentrancy {\n        //IF THE AMOUNT IS TOO BIG FOR LIQUIDITY POOL TO RETURN\n        if (_amount >= getAssetOne()) {\n            payable(msg.sender).transfer(msg.value);\n            revert amountTooBig();\n        }\n        //PAY THE ETH FEE\n        if (msg.value < swapFee) {\n            revert notEnoughGas();\n        }\n        yield += swapFee;\n        uint256 unrequiredFee = msg.value - swapFee; // In case the msg.sender sent more value than it is required\n        //CALCULATION\n        uint256 n = getAssetTwo();\n        uint256 assetOne = getAssetOne() + _amount;\n        uint256 assetTwo = liquidity / assetOne;\n        uint256 result = n - assetTwo;\n        //SENDING THE OPPOSITE ASSET TO THE CALLER FROM LIQUIDITY POOL\n        IERC20(assetOneAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        IERC20(assetTwoAddress).transfer(msg.sender, result);\n        (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n        require(sent, \"Failed to send Ether\");\n        //EVENTS\n        emit priceChanged(assetOneAddress, assetOnePrice());\n        emit priceChanged(assetTwoAddress, assetTwoPrice());\n    }\n\n    /**\n     * @dev Function to sell the second asset and receive the first asset.\n     * @param _amount The amount of the second asset to sell.\n     */\n    function sellAssetTwo(uint256 _amount) public payable noReentrancy {\n        //IF THE AMOUNT IS TOO BIG FOR LIQUIDITY POOL TO RETURN\n        if (_amount >= getAssetTwo()) {\n            payable(msg.sender).transfer(msg.value); // Transfer value back\n            revert amountTooBig();\n        }\n        //PAY THE ETH FEE\n        if (msg.value < swapFee) {\n            revert notEnoughGas();\n        }\n        yield += swapFee;\n        uint256 unrequiredFee = msg.value - swapFee; // In case the msg.sender sent more value than it is required\n        //CALCULATION\n        uint256 n = getAssetOne();\n        uint256 assetTwo = getAssetTwo() + _amount;\n        uint256 assetOne = liquidity / assetTwo;\n        uint256 result = n - assetOne;\n        //GETTING THE ASSET FROM CALLER TO THE LIQUIDITY POOL AND SENDING THE OPPOSITE ASSET TO THE CALLER FROM LIQUIDITY POOL\n        IERC20(assetTwoAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        IERC20(assetOneAddress).transfer(msg.sender, result);\n        (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n        require(sent, \"Failed to send Ether\");\n        //EVENTS\n        emit priceChanged(assetOneAddress, assetOnePrice());\n        emit priceChanged(assetTwoAddress, assetTwoPrice());\n    }\n\n    /**\n     * @dev Function to get the current balance of a given asset held by the contract.\n     * @param _address The address of the asset.\n     * @return The current balance of the asset.\n     */\n    function getAssetBalace(address _address) public view returns (uint256) {\n        return IERC20(_address).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the current price of the first asset in terms of the second asset.\n     * @return The current price of the first asset * 10**18.\n     */\n    function assetOnePrice() public view returns (uint256) {\n        return (getAssetTwo() * 1 ether) / getAssetOne();\n    }\n\n    /**\n     * @dev Function to get the current price of the second asset in terms of the first asset.\n     * @return The current price of the second asset * 10**18.\n     */\n    function assetTwoPrice() public view returns (uint256) {\n        return (getAssetOne() * 1 ether) / getAssetTwo();\n    }\n\n    /**\n     * @dev Function to get the amount of the first asset held by the contract.\n     * @return The current balance of the first asset.\n     */\n    function getAssetOne() public view returns (uint256) {\n        return IERC20(assetOneAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the amount of the second asset held by the contract.\n     * @return The current balance of the second asset.\n     */\n    function getAssetTwo() public view returns (uint256) {\n        return IERC20(assetTwoAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the quantity of LP tokens owned by a specific address.\n     * @param _address The address of the LP token holder.\n     * @return The quantity of LP tokens owned by the address.\n     */\n    function getLpTokenQuantity(\n        address _address\n    ) public view returns (uint256) {\n        if (msg.sender != owner && _address == msg.sender) {\n            revert addressNotCorrect();\n        }\n        return lpTokenQuantity[_address];\n    }\n\n    /**\n     * @dev Function to get the current ETH balance of the contract.\n     * @return The current ETH balance of the contract.\n     */\n    function addressBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Function to get the quantity of the second asset that would be returned for a given amount of the first asset.\n     * @param sellingAsset The address of the asset being sold.\n     * @param _amount The amount of the first asset being sold.\n     * @return The quantity of the second asset that would be returned\n     */\n    function getSwapQuantity(\n        address sellingAsset,\n        uint256 _amount\n    ) public view returns (uint256) {\n        if (sellingAsset == assetOneAddress) {\n            uint256 newAssetOne = getAssetOne() + _amount;\n            uint256 newAssetTwo = liquidity / newAssetOne;\n            return getAssetTwo() - newAssetTwo;\n        } else if (sellingAsset == assetTwoAddress) {\n            uint256 newAssetTwo = getAssetTwo() + _amount;\n            uint256 newAssetOne = liquidity / newAssetTwo;\n            return getAssetOne() - newAssetOne;\n        } else {\n            revert assetNotCorrect();\n        }\n    }\n\n    /**\n     * @dev Function to get the second part of the liquidity token pair needed for providing liquidity.\n     * @param _asset The address of the asset.\n     * @param _amount The amount of the asset.\n     * @return The quantity of the second asset needed for providing liquidity.\n     */\n    function amountOfOppositeTokenNeeded(\n        address _asset,\n        uint256 _amount\n    ) public view returns (uint256) {\n        uint256 ratio;\n        if (_asset == assetOneAddress) {\n            ratio = (getAssetTwo() * 1 ether) / getAssetOne();\n        } else {\n            ratio = (getAssetOne() * 1 ether) / getAssetTwo();\n        }\n        uint256 amountNeeded = (_amount * ratio) / 1 ether;\n        return amountNeeded;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Yield Farming and Time Locks\n\n    // Daily yield tracking\n    mapping(address => uint256) public yieldTaken;\n\n    /**\n     * @dev Function to allow users to claim their yield. Can be called once a day.\n     */\n    function getYield() public payable {\n        if (isTime() == false) {\n            revert notEnoughTimePassed();\n        }\n        //NOW SEND BACK THE AVAILABLE YIELD\n        uint16 destinationChain = PoolTracker(owner).destinationChain();\n        IZKBridge zkBridge = PoolTracker(owner).zkBridge();\n        address yieldCalculator = PoolTracker(owner).yieldCalculator();\n        bytes memory newPayload = abi.encode(msg.sender);\n        uint256 fee = zkBridge.estimateFee(destinationChain);\n        zkBridge.send{value: fee}(\n            destinationChain,\n            yieldCalculator,\n            newPayload\n        );\n        // Pay this to our contract which will fund the bridge contract with tokens\n        uint256 bridgeFee = zkBridge.estimateFee(destinationChain);\n        (bool sent, ) = payable(owner).call{value: bridgeFee}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n\n    function zkReceive(\n        uint16 srcChainId,\n        address srcAddress,\n        uint64 nonce,\n        bytes calldata payload\n    ) external {\n        (uint256 availableYield, address user) = abi.decode(\n            payload,\n            (uint256, address)\n        );\n        //TODO handle your business\n        if (availableYield > address(this).balance) {\n            revert notEnoughTokens(); // IN CASE THERE IS A LOT OF PEOPLE GETTING YIELD AT ONCE AND RATIOS GET CHANGED TOO MUCH\n        }\n        yieldTaken[user] += availableYield;\n        (bool sent, ) = payable(user).call{value: availableYield}(\"\");\n        require(sent, \"Failed to send Ether\");\n        // EMIT EVENT\n        emit yieldFarmed(msg.sender, availableYield);\n    }\n\n    // Timestamp mapping for yield farming\n    mapping(address => uint256) public lastYieldFarmedTime;\n    mapping(address => uint256) public initialLiquidityProvidedTime;\n\n    /**\n     * @dev Function to check if enough time has passed for the user to claim yield.\n     * @return Whether enough time has passed or not.\n     */\n    function isTime() public view returns (bool) {\n        lastYieldFarmedTime[msg.sender];\n        uint256 currentStamp = block.timestamp;\n        if ((lastYieldFarmedTime[msg.sender] + 1 days) < currentStamp) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Function to check if enough time has passed since the initial liquidity was provided.\n     * @return Whether enough time has passed or not.\n     */\n    function isTimeInitialLiquidity() public view returns (bool) {\n        if (\n            block.timestamp >\n            (initialLiquidityProvidedTime[msg.sender] + 365 days)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Fallback function if address calls unexisting function, but contains msg.data\n     * @notice The transaction gets reverted since the contract doesn't have the infrastructure to process it\n     */\n    fallback() external payable {\n        revert needToCallExistingFunction();\n    }\n\n    /**\n     * @dev Receive function if address calls unexisting function, without msg.data\n     * @notice The transaction gets reverted since the contract doesn't have the infrastructure to process it\n     */\n    receive() external payable {\n        revert needToCallExistingFunction();\n    }\n}\n"
    },
    "contracts/Dex/PoolMetrics.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// Importing necessary contracts and interfaces\nimport \"./LiquidityPool.sol\";\nimport \"./PoolTracker.sol\";\nimport \"../tests/MockV3Aggregator.sol\";\n\ncontract PoolMetrics {\n    PoolTracker poolTracker;\n    address ethPriceFeed;\n\n    constructor(address _poolTracker, address _ethPriceFeed) {\n        poolTracker = PoolTracker(_poolTracker);\n        ethPriceFeed = _ethPriceFeed;\n    }\n\n    function marketCap(address tokenAddress) public view returns (uint256) {\n        return usdValue(tokenAddress, IERC20(tokenAddress).totalSupply());\n    }\n\n    function pairMarketCap(\n        address tokenAddress,\n        address tokenAddress2\n    ) public view returns (uint256) {\n        uint256 tokenAmount = IERC20(tokenAddress).totalSupply();\n        uint256 tokenAmount2 = IERC20(tokenAddress2).totalSupply();\n        uint256 totalMarketCap = usdValue(tokenAddress, tokenAmount) +\n            usdValue(tokenAddress2, tokenAmount2);\n        return totalMarketCap;\n    }\n\n    function tvl(address tokenAddress) public view returns (uint256) {\n        uint256 tokensLocked;\n        uint256 poolPairLength = poolTracker.getPoolPairsLength(tokenAddress);\n        for (uint256 i; i < poolPairLength; i++) {\n            address tokenAddress2 = poolTracker.poolPairs(tokenAddress, i);\n            LiquidityPool pool = poolTracker.pairToPool(\n                tokenAddress,\n                tokenAddress2\n            );\n            tokensLocked += IERC20(tokenAddress).balanceOf(address(pool));\n        }\n        return usdValue(tokenAddress, tokensLocked);\n    }\n\n    function pairTvl(\n        address tokenAddress,\n        address tokenAddress2\n    ) public view returns (uint256) {\n        LiquidityPool pool = poolTracker.pairToPool(\n            tokenAddress,\n            tokenAddress2\n        );\n        uint256 tokenAmount = IERC20(tokenAddress).balanceOf(address(pool));\n        uint256 tokenAmount2 = IERC20(tokenAddress2).balanceOf(address(pool));\n        uint256 totalTvl = usdValue(tokenAddress, tokenAmount) +\n            usdValue(tokenAddress2, tokenAmount2);\n        return totalTvl;\n    }\n\n    function tvlRatio(address tokenAddress) public view returns (uint256) {\n        return (tvl(tokenAddress) * 100) / marketCap(tokenAddress);\n    }\n\n    function totalRoi(\n        address tokenAddress,\n        address tokenAddress2\n    ) public view returns (uint256) {\n        LiquidityPool pool = poolTracker.pairToPool(\n            tokenAddress,\n            tokenAddress2\n        );\n        uint256 profit = pool.yield() * uint256(usdConverter(ethPriceFeed));\n        uint256 tokenAmount = IERC20(tokenAddress).balanceOf(address(pool));\n        uint256 tokenAmount2 = IERC20(tokenAddress2).balanceOf(address(pool));\n        return\n            (profit * 100) /\n            (usdValue(tokenAddress, tokenAmount) +\n                usdValue(tokenAddress2, tokenAmount2));\n    }\n\n    function dailyRoi(\n        address tokenAddress,\n        address tokenAddress2\n    ) public view returns (uint256) {\n        return\n            (uint256(usdConverter(ethPriceFeed)) *\n                dailyRate(tokenAddress, tokenAddress2) *\n                10000) / pairTvl(tokenAddress, tokenAddress2);\n    }\n\n    // In eth\n    function dailyRate(\n        address tokenAddress,\n        address tokenAddress2\n    ) public view returns (uint256) {\n        LiquidityPool pool = poolTracker.pairToPool(\n            tokenAddress,\n            tokenAddress2\n        );\n        uint256 yield = pool.yield();\n        uint256 deployTimeStamp = pool.initialLiquidityProvidedTime(\n            pool.owner()\n        );\n        uint256 daysSinceDeployed = (block.timestamp - deployTimeStamp) /\n            60 /\n            24; // seconds / hours / days\n        return yield / daysSinceDeployed;\n    }\n\n    function usdValue(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public view returns (uint256) {\n        // If it is a routing token\n        for (uint256 i; i < poolTracker.getRoutingAddressesLength(); i++) {\n            (address routingAddress, address priceFeed) = poolTracker\n                .routingAddresses(i);\n            if (routingAddress == tokenAddress) {\n                return uint256(usdConverter(priceFeed)) * tokenAmount;\n            }\n        }\n        // If there is a direct pool with routing token\n        for (uint256 i; i < poolTracker.getRoutingAddressesLength(); i++) {\n            (address routingAddress, address priceFeed) = poolTracker\n                .routingAddresses(i);\n            if (\n                address(poolTracker.pairToPool(tokenAddress, routingAddress)) !=\n                address(0)\n            ) {\n                // Token value\n                uint256 tokenValue = LiquidityPool(\n                    poolTracker.pairToPool(tokenAddress, routingAddress)\n                ).getSwapQuantity(tokenAddress, 1);\n                return uint256(usdConverter(priceFeed)) * tokenValue;\n            }\n        }\n        return 0;\n    }\n\n    function usdConverter(address priceAddress) internal view returns (int) {\n        (, int answer, , , ) = AggregatorV3Interface(priceAddress)\n            .latestRoundData();\n        return answer;\n    }\n}\n"
    },
    "contracts/Dex/PoolTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// Importing necessary contracts and interfaces\nimport \"./LiquidityPool.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../Router/InterfaceBridge.sol\";\n\n// Custom error definitions for specific failure conditions\nerror PoolTracker_pairAlreadyExists();\nerror PoolTracker_cantSwapSameToken();\n\n/**\n * @title PoolTracker\n * @dev Manages the creation and tracking of liquidity pools within a decentralized finance ecosystem.\n * Utilizes Chainlink for accurate price feeds and OpenZeppelin's ERC20 for token interactions.\n * Implements reentrancy guards to mitigate potential security vulnerabilities in contract interactions.\n */\ncontract PoolTracker {\n    // The owner of the PoolTracker contract, set to the deployer.\n    address owner;\n\n    // Constructor: Sets the contract deployer as the owner.\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Reentrancy Guard\n    bool internal locked;\n    uint16 public destinationChain = 23; // Hard coded due to Size limit, OPBNB destination chain\n    IZKBridge public zkBridge =\n        IZKBridge(0xb20F0105f3598652a3bE569132F7b3F341106dDC); // Hard coded due to size limit\n    address public yieldCalculator;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert();\n        }\n        _;\n    }\n\n    // Tracker for created pools, will add to database\n    event poolCreated(LiquidityPool pool, address assetOne, address assetTwo);\n\n    // Mapping of pool Pairs, to store existing ones\n    mapping(address => address[]) public poolPairs;\n\n    // Mapping a pool to the contracts, in case we wont store it in the database\n    mapping(address => mapping(address => LiquidityPool)) public pairToPool;\n\n    // All the available tokens\n    address[] public tokens;\n\n    // Mapping of pool per Owner\n    mapping(address => LiquidityPool[]) public poolOwner;\n\n    /**\n     * @dev Creates a liquidity pool for a given pair of ERC20 tokens. This function handles the initial\n     * transfer of token amounts from the caller, sets up the liquidity pool, and updates internal mappings.\n     * Emits a PoolCreated event upon successful creation.\n     *\n     * Requirements:\n     * - The token pair must not already have an existing pool.\n     * - The caller must have approved the contract to spend the necessary token amounts.\n     *\n     * @param _assetOneAddress The address of the first token in the pair.\n     * @param _assetTwoAddress The address of the second token in the pair.\n     * @param amountOne The amount of the first token to add to the pool.\n     * @param amountTwo The amount of the second token to add to the pool.\n     */\n    function createPool(\n        address _assetOneAddress,\n        address _assetTwoAddress,\n        uint256 amountOne,\n        uint256 amountTwo\n    ) external noReentrancy {\n        if (\n            exists(_assetOneAddress, _assetTwoAddress)\n        ) // To prevent duplicate pools\n        {\n            revert PoolTracker_pairAlreadyExists();\n        }\n        // Transfer of tokens\n        IERC20(_assetOneAddress).transferFrom(\n            msg.sender,\n            address(this),\n            amountOne\n        );\n        IERC20(_assetTwoAddress).transferFrom(\n            msg.sender,\n            address(this),\n            amountTwo\n        );\n        // Creation of pool\n        LiquidityPool poolAddress = new LiquidityPool(\n            _assetOneAddress,\n            _assetTwoAddress\n        );\n        // Approve\n        IERC20(_assetOneAddress).approve(address(poolAddress), amountOne);\n        IERC20(_assetTwoAddress).approve(address(poolAddress), amountTwo);\n        // Add initial liquidity\n        poolAddress.addInitialLiquidity(amountOne, amountTwo);\n        // Update mappings\n        poolOwner[msg.sender].push(poolAddress);\n        poolPairs[_assetOneAddress].push(_assetTwoAddress);\n        poolPairs[_assetTwoAddress].push(_assetOneAddress);\n        pairToPool[_assetOneAddress][_assetTwoAddress] = poolAddress;\n        pairToPool[_assetTwoAddress][_assetOneAddress] = poolAddress;\n\n        if (tokenExists(_assetOneAddress) == false) {\n            tokens.push(_assetOneAddress);\n        }\n        if (tokenExists(_assetTwoAddress) == false) {\n            tokens.push(_assetTwoAddress);\n        }\n        // Emit the event\n        emit poolCreated(poolAddress, _assetOneAddress, _assetTwoAddress);\n    }\n\n    /**\n     * @dev Checks if a liquidity pool exists for a given pair of tokens.\n     *\n     * @param token1 The address of the first token.\n     * @param token2 The address of the second token.\n     * @return bool Returns true if the pool exists, false otherwise.\n     */\n    function exists(address token1, address token2) public view returns (bool) {\n        bool exist;\n        for (uint256 i; i < poolPairs[token1].length; i++) {\n            if (poolPairs[token1][i] == token2) {\n                exist = true;\n            }\n        }\n        return exist;\n    }\n\n    /**\n     * @dev Checks if a token is already tracked by the contract.\n     *\n     * @param tokenAddress The address of the token to check.\n     * @return bool Returns true if the token is tracked, false otherwise.\n     */\n    function tokenExists(address tokenAddress) public view returns (bool) {\n        bool exist;\n        for (uint256 i; i < tokens.length; i++) {\n            if (tokenAddress == tokens[i]) {\n                exist = true;\n                break;\n            }\n        }\n        return exist;\n    }\n\n    // Routing token\n    struct routingAddress {\n        address tokenAddress;\n        address priceFeed;\n    }\n\n    // Array of routing Tokens\n    routingAddress[] public routingAddresses;\n\n    /**\n     * @dev Allows the contract owner to add or update the routing address for a token.\n     * This is used for token swaps and price feed lookups.\n     *\n     * @param tokenAddress The token for which to set the routing.\n     * @param priceFeed The Chainlink price feed address for the token.\n     */\n    function addRoutingAddress(\n        address tokenAddress,\n        address priceFeed\n    ) public onlyOwner {\n        if (routingAddresses.length == 0) {\n            routingAddresses.push(routingAddress(tokenAddress, priceFeed));\n        } else {\n            for (uint256 i = 0; i < routingAddresses.length; i++) {\n                if (routingAddresses[i].tokenAddress == tokenAddress) {\n                    routingAddresses[i] = routingAddress(\n                        tokenAddress,\n                        priceFeed\n                    );\n                    break;\n                } else if (i == routingAddresses.length - 1) {\n                    routingAddresses.push(\n                        routingAddress(tokenAddress, priceFeed)\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Determines the optimal routing token for a swap between two tokens,\n     * based on available liquidity and price feeds.\n     *\n     * @param address1 The address of the first token.\n     * @param address2 The address of the second token.\n     * @return address The address of the optimal routing token.\n     */\n    function tokenToRoute(\n        address address1,\n        address address2\n    ) public view returns (address) {\n        if (address1 == address2) {\n            revert PoolTracker_cantSwapSameToken();\n        }\n        address[] memory token1pairs = poolPairs[address1];\n        address[] memory token2pairs = poolPairs[address2];\n\n        address routingToken;\n        int routingTokenLiquidity;\n\n        for (uint256 i; i < token1pairs.length; i++) {\n            for (uint256 a; a < token2pairs.length; a++) {\n                if (token1pairs[i] == token2pairs[a]) {\n                    for (uint256 b; b < routingAddresses.length; b++) {\n                        if (\n                            routingAddresses[b].tokenAddress == token1pairs[i]\n                        ) {\n                            (, int answer, , , ) = AggregatorV3Interface(\n                                routingAddresses[b].priceFeed\n                            ).latestRoundData();\n                            int liquidity;\n                            LiquidityPool pool1 = pairToPool[address1][\n                                routingAddresses[b].tokenAddress\n                            ];\n                            LiquidityPool pool2 = pairToPool[address2][\n                                routingAddresses[b].tokenAddress\n                            ];\n                            uint256 balance1 = IERC20(\n                                routingAddresses[b].tokenAddress\n                            ).balanceOf(address(pool1));\n                            uint256 balance2 = IERC20(\n                                routingAddresses[b].tokenAddress\n                            ).balanceOf(address(pool2));\n                            liquidity =\n                                (int(balance1) + int(balance2)) *\n                                answer;\n                            if (liquidity > routingTokenLiquidity) {\n                                // Best choice so far if the liquidity is bigger than previous best token\n                                routingToken = routingAddresses[b].tokenAddress;\n                                routingTokenLiquidity = liquidity;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return routingToken;\n    }\n\n    function addYieldCalculator(address _yieldCalculator) public onlyOwner {\n        yieldCalculator = _yieldCalculator;\n    }\n\n    /**\n     * @dev Returns all array of all tradable tokens on the platform\n     *\n     * @return array Returns tokens array.\n     */\n    function tokenList() public view returns (address[] memory) {\n        return tokens;\n    }\n\n    function getRoutingAddressesLength() public view returns (uint256) {\n        return routingAddresses.length;\n    }\n\n    function getPoolPairsLength(\n        address tokenAddress\n    ) public view returns (uint256) {\n        return poolPairs[tokenAddress].length;\n    }\n}\n"
    },
    "contracts/Router/InterfaceBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IZKBridge {\n    // @notice send a zkBridge message to the specified address at a zkBridge endpoint.\n    // @param dstChainId - the destination chain identifier\n    // @param dstAddress - the address on destination chain\n    // @param payload - a custom bytes payload to send to the destination contract\n    function send(\n        uint16 dstChainId,\n        address dstAddress,\n        bytes memory payload\n    ) external payable returns (uint64 nonce);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param dstChainId - the destination chain identifier\n    function estimateFee(uint16 dstChainId) external view returns (uint256 fee);\n}\n\ninterface IZKBridgeReceiver {\n    // @notice zkBridge endpoint will invoke this function to deliver the message on the destination\n    // @param srcChainId - the source endpoint identifier\n    // @param srcAddress - the source sending contract address from the source chain\n    // @param nonce - the ordered message nonce\n    // @param payload - a custom bytes payload from send chain\n    function zkReceive(\n        uint16 srcChainId,\n        address srcAddress,\n        uint64 nonce,\n        bytes calldata payload\n    ) external;\n}\n"
    },
    "contracts/tests/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\nimport \"@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol\";\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}