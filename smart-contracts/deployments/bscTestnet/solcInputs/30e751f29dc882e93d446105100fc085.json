{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface {\n  uint256 public constant override version = 0;\n\n  uint8 public override decimals;\n  int256 public override latestAnswer;\n  uint256 public override latestTimestamp;\n  uint256 public override latestRound;\n\n  mapping(uint256 => int256) public override getAnswer;\n  mapping(uint256 => uint256) public override getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(uint8 _decimals, int256 _initialAnswer) {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(int256 _answer) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description() external pure override returns (string memory) {\n    return \"v0.8/tests/MockV3Aggregator.sol\";\n  }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/Dex/LiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\nerror assetNotCorrect();\nerror notEnoughTokens();\nerror notEnoughGas();\nerror notEnoughTimePassed();\nerror initialLiquidityAlreadyProvided();\nerror addressNotCorrect();\nerror amountTooBig();\nerror needToCallExistingFunction();\n\n/**\n * @title LiquidityPool\n * @dev A decentralized liquidity pool contract for swapping assets and providing liquidity.\n */\ncontract LiquidityPool {\n    // Events\n    event priceChanged(address _asset, uint256 price);\n    event liquidityAdded(\n        address indexed _address,\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    );\n    event liquidityRemoved(\n        address indexed _address,\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    );\n    event yieldFarmed(address indexed _address, uint256 _amount);\n\n    // Token Addresses\n    address public assetOneAddress;\n    address public assetTwoAddress;\n\n    // Liquidity and Yield (fees)\n    uint256 public initialLiquidity;\n    uint256 public liquidity;\n    uint256 public yield;\n    uint256 public swapFee = 1000000000000000;\n    address public owner;\n\n    // Reentrancy Guard\n    bool internal locked;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /**\n     * @dev Modifier to restrict functions only to the owner.\n     */\n    modifier onlyOwner() {\n        msg.sender == owner;\n        _;\n    }\n\n    /**\n     * @dev Constructor to initialize the liquidity pool with two asset addresses.\n     * @param _assetOneAddress The address of the first asset.\n     * @param _assetTwoAddress The address of the second asset.\n     */\n    constructor(address _assetOneAddress, address _assetTwoAddress) {\n        assetOneAddress = _assetOneAddress;\n        assetTwoAddress = _assetTwoAddress;\n        owner = msg.sender;\n        swapFee = 1000000000000000; // 0.001 ether\n    }\n\n    /**\n     * @dev Function to change the swap fee. Only callable by the owner.\n     * @param newSwapFee The new swap fee to set.\n     */\n    function changeSwapFee(uint256 newSwapFee) public onlyOwner {\n        swapFee = newSwapFee;\n    }\n\n    // TRACK THE LP TOKEN QUANTITY, INITIAL LIQUIDITY\n    mapping(address => uint256) public lpTokenQuantity;\n\n    /**\n     * @dev Function to add initial liquidity to the pool. Only callable by the owner.\n     * @dev Needs the ERC-20 approval for transferFrom.\n     * @param _assetOneAmount The amount of the first asset to add.\n     * @param _assetTwoAmount The amount of the second asset to add.\n     */\n    function addInitialLiquidity(\n        uint256 _assetOneAmount,\n        uint256 _assetTwoAmount\n    ) public onlyOwner {\n        if (initialLiquidityProvidedTime[owner] > 0) {\n            revert initialLiquidityAlreadyProvided();\n        }\n        initialLiquidityProvidedTime[msg.sender] = block.timestamp;\n\n        // SENDS THE TOKENS TO THE LIQUIDITY POOL\n        IERC20(assetOneAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _assetOneAmount\n        );\n        IERC20(assetTwoAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _assetTwoAmount\n        );\n\n        // SET THE INITIAL LIQUIDITY\n        initialLiquidity = _assetOneAmount * _assetTwoAmount;\n        liquidity = initialLiquidity;\n\n        // GIVE LP TOKENS TO THE INITIAL LIQUIDITY PROVIDER\n        lpTokenQuantity[msg.sender] = initialLiquidity;\n\n        // EMIT EVENT\n        emit liquidityAdded(msg.sender, _assetOneAmount, _assetTwoAmount);\n    }\n\n    /**\n     * @dev Function to add additional liquidity to the pool.\n     * @dev Needs the ERC-20 approval for transferFrom.\n     * @param _asset The address of the first asset.\n     * @param _secondAsset The address of the second asset.\n     * @param _amount The amount of the first asset to add.\n     */\n    function addLiquidity(\n        address _asset,\n        address _secondAsset,\n        uint256 _amount\n    ) public noReentrancy {\n        // SET THE RATIO, require token balance provided in ERC20, reverted if too low\n        IERC20(_secondAsset).transferFrom(\n            msg.sender,\n            address(this),\n            amountOfOppositeTokenNeeded(_asset, _amount)\n        );\n        IERC20(_asset).transferFrom(msg.sender, address(this), _amount);\n\n        // give lp tokens to new liquidity provider\n        lpTokenQuantity[msg.sender] += (_amount *\n            amountOfOppositeTokenNeeded(_asset, _amount));\n        liquidity += (_amount * amountOfOppositeTokenNeeded(_asset, _amount));\n\n        // EMIT EVENT\n        emit liquidityAdded(\n            msg.sender,\n            amountOfOppositeTokenNeeded(_asset, _amount),\n            _amount\n        );\n    }\n\n    /**\n     * @dev Function to remove liquidity from the pool.\n     * @param _amount The percentage of liquidity to withdraw(10 -> 10%).\n     */\n    function removeLiquidity(uint256 _amount) public noReentrancy {\n        uint256 userLpTokens = lpTokenQuantity[msg.sender];\n        uint256 percentageOfLiquidity = (userLpTokens * 1 ether) / liquidity; // How much user owns out of all Liquidity in percentage\n        uint256 percentageOfUserLiquidity = (percentageOfLiquidity * _amount) /\n            100; // How much out of their liquidity they want to withdraw in percentage\n        uint256 resultAssetOne = (percentageOfUserLiquidity * getAssetOne()) /\n            1 ether;\n        uint256 resultAssetTwo = (percentageOfUserLiquidity * getAssetTwo()) /\n            1 ether;\n        // condition for owner, because of the initial liquidity timer\n        if (\n            (msg.sender == owner) &&\n            (isTimeInitialLiquidity() == false) &&\n            //the owner has the ability to withdraw liquidity if it wasn't part of initial liquidity\n            ((lpTokenQuantity[msg.sender] - (resultAssetOne * resultAssetTwo)) <\n                initialLiquidity)\n        ) {\n            revert notEnoughTokens();\n        }\n        // check balance if it is high enough to continue, can't get reverted at transfer, it should have the balance but just in case\n        if (\n            IERC20(assetOneAddress).balanceOf(address(this)) < resultAssetOne ||\n            IERC20(assetTwoAddress).balanceOf(address(this)) < resultAssetTwo\n        ) {\n            revert notEnoughTokens();\n        }\n        IERC20(assetOneAddress).transfer(msg.sender, resultAssetOne);\n        IERC20(assetTwoAddress).transfer(msg.sender, resultAssetTwo);\n\n        // EMIT EVENT\n        emit liquidityRemoved(msg.sender, resultAssetOne, resultAssetTwo);\n    }\n\n    /**\n     * @dev Function to sell the first asset and receive the second asset.\n     * @param _amount The amount of the first asset to sell.\n     */\n    function sellAssetOne(uint256 _amount) public payable noReentrancy {\n        //IF THE AMOUNT IS TOO BIG FOR LIQUIDITY POOL TO RETURN\n        if (_amount >= getAssetOne()) {\n            payable(msg.sender).transfer(msg.value);\n            revert amountTooBig();\n        }\n        //PAY THE ETH FEE\n        if (msg.value < swapFee) {\n            revert notEnoughGas();\n        }\n        yield += swapFee;\n        uint256 unrequiredFee = msg.value - swapFee; // In case the msg.sender sent more value than it is required\n        //CALCULATION\n        uint256 n = getAssetTwo();\n        uint256 assetOne = getAssetOne() + _amount;\n        uint256 assetTwo = liquidity / assetOne;\n        uint256 result = n - assetTwo;\n        //SENDING THE OPPOSITE ASSET TO THE CALLER FROM LIQUIDITY POOL\n        IERC20(assetOneAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        IERC20(assetTwoAddress).transfer(msg.sender, result);\n        (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n        require(sent, \"Failed to send Ether\");\n        //EVENTS\n        emit priceChanged(assetOneAddress, assetOnePrice());\n        emit priceChanged(assetTwoAddress, assetTwoPrice());\n    }\n\n    /**\n     * @dev Function to sell the second asset and receive the first asset.\n     * @param _amount The amount of the second asset to sell.\n     */\n    function sellAssetTwo(uint256 _amount) public payable noReentrancy {\n        //IF THE AMOUNT IS TOO BIG FOR LIQUIDITY POOL TO RETURN\n        if (_amount >= getAssetTwo()) {\n            payable(msg.sender).transfer(msg.value); // Transfer value back\n            revert amountTooBig();\n        }\n        //PAY THE ETH FEE\n        if (msg.value < swapFee) {\n            revert notEnoughGas();\n        }\n        yield += swapFee;\n        uint256 unrequiredFee = msg.value - swapFee; // In case the msg.sender sent more value than it is required\n        //CALCULATION\n        uint256 n = getAssetOne();\n        uint256 assetTwo = getAssetTwo() + _amount;\n        uint256 assetOne = liquidity / assetTwo;\n        uint256 result = n - assetOne;\n        //GETTING THE ASSET FROM CALLER TO THE LIQUIDITY POOL AND SENDING THE OPPOSITE ASSET TO THE CALLER FROM LIQUIDITY POOL\n        IERC20(assetTwoAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        IERC20(assetOneAddress).transfer(msg.sender, result);\n        (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n        require(sent, \"Failed to send Ether\");\n        //EVENTS\n        emit priceChanged(assetOneAddress, assetOnePrice());\n        emit priceChanged(assetTwoAddress, assetTwoPrice());\n    }\n\n    /**\n     * @dev Function to get the current balance of a given asset held by the contract.\n     * @param _address The address of the asset.\n     * @return The current balance of the asset.\n     */\n    function getAssetBalace(address _address) public view returns (uint256) {\n        return IERC20(_address).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the current price of the first asset in terms of the second asset.\n     * @return The current price of the first asset * 10**18.\n     */\n    function assetOnePrice() public view returns (uint256) {\n        return (getAssetTwo() * 1 ether) / getAssetOne();\n    }\n\n    /**\n     * @dev Function to get the current price of the second asset in terms of the first asset.\n     * @return The current price of the second asset * 10**18.\n     */\n    function assetTwoPrice() public view returns (uint256) {\n        return (getAssetOne() * 1 ether) / getAssetTwo();\n    }\n\n    /**\n     * @dev Function to get the amount of the first asset held by the contract.\n     * @return The current balance of the first asset.\n     */\n    function getAssetOne() public view returns (uint256) {\n        return IERC20(assetOneAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the amount of the second asset held by the contract.\n     * @return The current balance of the second asset.\n     */\n    function getAssetTwo() public view returns (uint256) {\n        return IERC20(assetTwoAddress).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function to get the quantity of LP tokens owned by a specific address.\n     * @param _address The address of the LP token holder.\n     * @return The quantity of LP tokens owned by the address.\n     */\n    function getLpTokenQuantity(\n        address _address\n    ) public view returns (uint256) {\n        if (msg.sender != owner && _address == msg.sender) {\n            revert addressNotCorrect();\n        }\n        return lpTokenQuantity[_address];\n    }\n\n    /**\n     * @dev Function to get the total liquidity in the pool.\n     * @return The total liquidity in the pool.\n     */\n    function getLiquidity() public view returns (uint256) {\n        return liquidity;\n    }\n\n    /**\n     * @dev Function to get the current swap fee percentage.\n     * @return The current swap fee percentage.\n     */\n    function getSwapFee() public view returns (uint256) {\n        return swapFee;\n    }\n\n    /**\n     * @dev Function to get the current ETH balance of the contract.\n     * @return The current ETH balance of the contract.\n     */\n    function addressBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @dev Function to get the quantity of the second asset that would be returned for a given amount of the first asset.\n     * @param sellingAsset The address of the asset being sold.\n     * @param _amount The amount of the first asset being sold.\n     * @return The quantity of the second asset that would be returned\n     */\n    function getSwapQuantity(\n        address sellingAsset,\n        uint256 _amount\n    ) public view returns (uint256) {\n        if (sellingAsset == assetOneAddress) {\n            uint256 newAssetOne = getAssetOne() + _amount;\n            uint256 newAssetTwo = liquidity / newAssetOne;\n            return getAssetTwo() - newAssetTwo;\n        } else if (sellingAsset == assetTwoAddress) {\n            uint256 newAssetTwo = getAssetTwo() + _amount;\n            uint256 newAssetOne = liquidity / newAssetTwo;\n            return getAssetOne() - newAssetOne;\n        } else {\n            revert assetNotCorrect();\n        }\n    }\n\n    /**\n     * @dev Function to get the second part of the liquidity token pair needed for providing liquidity.\n     * @param _asset The address of the asset.\n     * @param _amount The amount of the asset.\n     * @return The quantity of the second asset needed for providing liquidity.\n     */\n    function amountOfOppositeTokenNeeded(\n        address _asset,\n        uint256 _amount\n    ) public view returns (uint256) {\n        uint256 ratio;\n        if (_asset == assetOneAddress) {\n            ratio = (getAssetTwo() * 1 ether) / getAssetOne();\n        } else {\n            ratio = (getAssetOne() * 1 ether) / getAssetTwo();\n        }\n        uint256 amountNeeded = (_amount * ratio) / 1 ether;\n        return amountNeeded;\n    }\n\n    /////////////////////////////////////////////////////////////////\n    // Yield Farming and Time Locks\n\n    // Daily yield tracking\n    mapping(address => uint256) public yieldTaken;\n\n    /**\n     * @dev Function to get the current yield amount available in the pool.\n     * @return The current yield amount.\n     */\n    function yieldAmount() public view returns (uint256) {\n        return yield;\n    }\n\n    /**\n     * @dev Function to allow users to claim their yield. Can be called once a day.\n     */\n    function getYield() public {\n        if (isTime() == false) {\n            revert notEnoughTimePassed();\n        }\n        lastYieldFarmedTime[msg.sender] = block.timestamp; // Reentrancy guard\n        uint256 yieldSoFar = yieldTaken[msg.sender];\n        uint256 userLiquidity = (lpTokenQuantity[msg.sender] * 100) / liquidity;\n        uint256 availableYield = ((yield -\n            ((yieldSoFar * 100) / userLiquidity)) * userLiquidity) / 100;\n        if (availableYield > address(this).balance) {\n            revert notEnoughTokens(); // IN CASE THERE IS A LOT OF PEOPLE GETTING YIELD AT ONCE AND RATIOS GET CHANGED TOO MUCH\n        }\n        yieldTaken[msg.sender] += availableYield;\n        payable(msg.sender).transfer(availableYield);\n\n        // EMIT EVENT\n        emit yieldFarmed(msg.sender, availableYield);\n    }\n\n    // Timestamp mapping for yield farming\n    mapping(address => uint256) public lastYieldFarmedTime;\n    mapping(address => uint256) public initialLiquidityProvidedTime;\n\n    /**\n     * @dev Function to check if enough time has passed for the user to claim yield.\n     * @return Whether enough time has passed or not.\n     */\n    function isTime() public view returns (bool) {\n        lastYieldFarmedTime[msg.sender];\n        uint256 currentStamp = block.timestamp;\n        if ((lastYieldFarmedTime[msg.sender] + 1 days) < currentStamp) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Function to check if enough time has passed since the initial liquidity was provided.\n     * @return Whether enough time has passed or not.\n     */\n    function isTimeInitialLiquidity() public view returns (bool) {\n        if (\n            block.timestamp >\n            (initialLiquidityProvidedTime[msg.sender] + 365 days)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Fallback function if address calls unexisting function, but contains msg.data\n     * @notice The transaction gets reverted since the contract doesn't have the infrastructure to process it\n     */\n    fallback() external payable {\n        revert needToCallExistingFunction();\n    }\n\n    /**\n     * @dev Receive function if address calls unexisting function, without msg.data\n     * @notice The transaction gets reverted since the contract doesn't have the infrastructure to process it\n     */\n    receive() external payable {\n        revert needToCallExistingFunction();\n    }\n}\n"
    },
    "contracts/Dex/PoolTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// Importing necessary contracts and interfaces\nimport \"./LiquidityPool.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n// Custom error definitions for specific failure conditions\nerror PoolTracker_noTokensDetected();\nerror PoolTracker_pairAlreadyExists();\nerror PoolTracker_addressNotAllowed();\nerror PoolTracker_cantSwapSameToken();\n\n/**\n * @title PoolTracker\n * @dev Manages the creation and tracking of liquidity pools within a decentralized finance ecosystem.\n * Utilizes Chainlink for accurate price feeds and OpenZeppelin's ERC20 for token interactions.\n * Implements reentrancy guards to mitigate potential security vulnerabilities in contract interactions.\n */\ncontract PoolTracker {\n    // The owner of the PoolTracker contract, set to the deployer.\n    address owner;\n\n    // Constructor: Sets the contract deployer as the owner.\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Reentrancy Guard\n    bool internal locked;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    // Tracker for created pools, will add to database\n    event poolCreated(LiquidityPool pool, address assetOne, address assetTwo);\n\n    // Mapping of pool Pairs, to store existing ones\n    mapping(address => address[]) public poolPairs;\n\n    // Mapping a pool to the contracts, in case we wont store it in the database\n    mapping(address => mapping(address => LiquidityPool)) public pairToPool;\n\n    // All the available tokens\n    address[] public tokens;\n\n    // Mapping of pool per Owner\n    mapping(address => LiquidityPool[]) public poolOwner;\n\n    /**\n     * @dev Creates a liquidity pool for a given pair of ERC20 tokens. This function handles the initial\n     * transfer of token amounts from the caller, sets up the liquidity pool, and updates internal mappings.\n     * Emits a PoolCreated event upon successful creation.\n     *\n     * Requirements:\n     * - The token pair must not already have an existing pool.\n     * - The caller must have approved the contract to spend the necessary token amounts.\n     *\n     * @param _assetOneAddress The address of the first token in the pair.\n     * @param _assetTwoAddress The address of the second token in the pair.\n     * @param amountOne The amount of the first token to add to the pool.\n     * @param amountTwo The amount of the second token to add to the pool.\n     */\n    function createPool(\n        address _assetOneAddress,\n        address _assetTwoAddress,\n        uint256 amountOne,\n        uint256 amountTwo\n    ) external noReentrancy {\n        if (\n            exists(_assetOneAddress, _assetTwoAddress)\n        ) // To prevent duplicate pools\n        {\n            revert PoolTracker_pairAlreadyExists();\n        }\n        // Transfer of tokens\n        IERC20(_assetOneAddress).transferFrom(\n            msg.sender,\n            address(this),\n            amountOne\n        );\n        IERC20(_assetTwoAddress).transferFrom(\n            msg.sender,\n            address(this),\n            amountTwo\n        );\n        // Creation of pool\n        LiquidityPool poolAddress = new LiquidityPool(\n            _assetOneAddress,\n            _assetTwoAddress\n        );\n        // Approve\n        IERC20(_assetOneAddress).approve(address(poolAddress), amountOne);\n        IERC20(_assetTwoAddress).approve(address(poolAddress), amountTwo);\n        // Add initial liquidity\n        poolAddress.addInitialLiquidity(amountOne, amountTwo);\n        // Update mappings\n        poolOwner[msg.sender].push(poolAddress);\n        poolPairs[_assetOneAddress].push(_assetTwoAddress);\n        poolPairs[_assetTwoAddress].push(_assetOneAddress);\n        pairToPool[_assetOneAddress][_assetTwoAddress] = poolAddress;\n        pairToPool[_assetTwoAddress][_assetOneAddress] = poolAddress;\n\n        if (tokenExists(_assetOneAddress) == false) {\n            tokens.push(_assetOneAddress);\n        }\n        if (tokenExists(_assetTwoAddress) == false) {\n            tokens.push(_assetTwoAddress);\n        }\n        // Emit the event\n        emit poolCreated(poolAddress, _assetOneAddress, _assetTwoAddress);\n    }\n\n    /**\n     * @dev Checks if a liquidity pool exists for a given pair of tokens.\n     *\n     * @param token1 The address of the first token.\n     * @param token2 The address of the second token.\n     * @return bool Returns true if the pool exists, false otherwise.\n     */\n    function exists(address token1, address token2) public view returns (bool) {\n        bool exist;\n        for (uint256 i; i < poolPairs[token1].length; i++) {\n            if (poolPairs[token1][i] == token2) {\n                exist = true;\n            }\n        }\n        return exist;\n    }\n\n    /**\n     * @dev Checks if a token is already tracked by the contract.\n     *\n     * @param tokenAddress The address of the token to check.\n     * @return bool Returns true if the token is tracked, false otherwise.\n     */\n    function tokenExists(address tokenAddress) public view returns (bool) {\n        bool exist;\n        for (uint256 i; i < tokens.length; i++) {\n            if (tokenAddress == tokens[i]) {\n                exist = true;\n                break;\n            }\n        }\n        return exist;\n    }\n\n    // Routing token\n    struct routingAddress {\n        address tokenAddress;\n        address priceFeed;\n    }\n\n    // Array of routing Tokens\n    routingAddress[] public routingAddresses;\n\n    /**\n     * @dev Allows the contract owner to add or update the routing address for a token.\n     * This is used for token swaps and price feed lookups.\n     *\n     * @param tokenAddress The token for which to set the routing.\n     * @param priceFeed The Chainlink price feed address for the token.\n     */\n    function addRoutingAddress(address tokenAddress, address priceFeed) public {\n        if (msg.sender != owner) {\n            revert PoolTracker_addressNotAllowed();\n        }\n        if (routingAddresses.length == 0) {\n            routingAddresses.push(routingAddress(tokenAddress, priceFeed));\n        } else {\n            for (uint256 i = 0; i < routingAddresses.length; i++) {\n                if (routingAddresses[i].tokenAddress == tokenAddress) {\n                    routingAddresses[i] = routingAddress(\n                        tokenAddress,\n                        priceFeed\n                    );\n                    break;\n                } else if (i == routingAddresses.length - 1) {\n                    routingAddresses.push(\n                        routingAddress(tokenAddress, priceFeed)\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Determines the optimal routing token for a swap between two tokens,\n     * based on available liquidity and price feeds.\n     *\n     * @param address1 The address of the first token.\n     * @param address2 The address of the second token.\n     * @return address The address of the optimal routing token.\n     */\n    function tokenToRoute(\n        address address1,\n        address address2\n    ) public view returns (address) {\n        if (address1 == address2) {\n            revert PoolTracker_cantSwapSameToken();\n        }\n        address[] memory token1pairs = poolPairs[address1];\n        address[] memory token2pairs = poolPairs[address2];\n\n        address routingToken;\n        int routingTokenLiquidity;\n\n        for (uint256 i; i < token1pairs.length; i++) {\n            for (uint256 a; a < token2pairs.length; a++) {\n                if (token1pairs[i] == token2pairs[a]) {\n                    for (uint256 b; b < routingAddresses.length; b++) {\n                        if (\n                            routingAddresses[b].tokenAddress == token1pairs[i]\n                        ) {\n                            (, int answer, , , ) = AggregatorV3Interface(\n                                routingAddresses[b].priceFeed\n                            ).latestRoundData();\n                            int liquidity;\n                            LiquidityPool pool1 = pairToPool[address1][\n                                routingAddresses[b].tokenAddress\n                            ];\n                            LiquidityPool pool2 = pairToPool[address2][\n                                routingAddresses[b].tokenAddress\n                            ];\n                            uint256 balance1 = IERC20(\n                                routingAddresses[b].tokenAddress\n                            ).balanceOf(address(pool1));\n                            uint256 balance2 = IERC20(\n                                routingAddresses[b].tokenAddress\n                            ).balanceOf(address(pool2));\n                            liquidity =\n                                (int(balance1) + int(balance2)) *\n                                answer;\n                            if (liquidity > routingTokenLiquidity) {\n                                // Best choice so far if the liquidity is bigger than previous best token\n                                routingToken = routingAddresses[b].tokenAddress;\n                                routingTokenLiquidity = liquidity;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return routingToken;\n    }\n\n    /**\n     * @dev Returns all array of all tradable tokens on the platform\n     *\n     * @return array Returns tokens array.\n     */\n    function tokenList() public view returns (address[] memory) {\n        return tokens;\n    }\n}\n"
    },
    "contracts/Dex/WeaveSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// Importing required contracts and interfaces\nimport \"./PoolTracker.sol\";\nimport \"./LiquidityPool.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\n// Error declaration for unswappable token pairs\nerror SwapRouter_tokensCantBeSwapped();\nerror SwapRouter_needToCallExistingFunction();\n\n/**\n * @title SwapRouter\n * @dev Facilitates token swaps utilizing defined liquidity pools, offering direct swaps and routed swaps through an intermediary.\n * Leverages the PoolTracker contract to access liquidity pool information and perform asset exchanges.\n */\ncontract SwapRouter {\n    // Emitted after a successful token swap\n    event swap(\n        address userAddress,\n        address address1,\n        address address2,\n        uint256 address1Amount,\n        uint256 address2Amount\n    );\n\n    // Reference to the PoolTracker contract for pool operations\n    PoolTracker poolTracker;\n\n    // Reentrancy Guard\n    bool internal locked;\n\n    /**\n     * @dev Modifier to prevent reentrancy attacks.\n     */\n    modifier noReentrancy() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /**\n     * @param tracker Address of the PoolTracker contract instance.\n     */\n    constructor(address tracker) {\n        poolTracker = PoolTracker(tracker);\n    }\n\n    /**\n     * @notice Swaps `inputAmount` of `address1` tokens for `address2` tokens.\n     * @dev This function supports direct swaps between tokens in a single pool or routed swaps through an intermediary token.\n     * Uses PoolTracker to determine the best swap path and perform the exchange.\n     * @param address1 The token being sold by the user.\n     * @param address2 The token being purchased by the user.\n     * @param inputAmount The amount of `address1` tokens to swap.\n     */\n    function swapAsset(\n        address address1,\n        address address2,\n        uint256 inputAmount\n    ) public payable noReentrancy {\n        if (poolTracker.exists(address1, address2)) {\n            // Direct swap scenario\n            LiquidityPool pool = poolTracker.pairToPool(address1, address2);\n            uint256 startingBalanceAddress2 = IERC20(address2).balanceOf(\n                address(this)\n            );\n            if (pool.assetOneAddress() == address1) {\n                IERC20(address1).transferFrom(\n                    msg.sender,\n                    address(this),\n                    inputAmount\n                );\n                IERC20(address1).approve(address(pool), inputAmount);\n                pool.sellAssetOne{value: pool.swapFee()}(inputAmount);\n            } else {\n                IERC20(address1).transferFrom(\n                    msg.sender,\n                    address(this),\n                    inputAmount\n                );\n                IERC20(address1).approve(address(pool), inputAmount);\n                pool.sellAssetTwo{value: pool.swapFee()}(inputAmount);\n            }\n            uint256 amountOutput = IERC20(address2).balanceOf(address(this)) -\n                startingBalanceAddress2;\n            IERC20(address2).transfer(msg.sender, amountOutput);\n            // Unrequired fee\n            uint256 unrequiredFee = msg.value - pool.swapFee(); // In case the msg.sender sent more value than it is required\n            (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n            require(sent, \"Failed to send Ether\");\n        } else if (poolTracker.tokenToRoute(address1, address2) != address(0)) {\n            // Routed swap scenario\n            address routingToken = poolTracker.tokenToRoute(address1, address2);\n            LiquidityPool pool1 = poolTracker.pairToPool(\n                address1,\n                routingToken\n            );\n            LiquidityPool pool2 = poolTracker.pairToPool(\n                address2,\n                routingToken\n            );\n            uint256 startingBalance = IERC20(routingToken).balanceOf(\n                address(this)\n            );\n            uint256 startingBalance2 = IERC20(address2).balanceOf(\n                address(this)\n            );\n            //SWAP 1, input token into routing  token\n            if (pool1.assetOneAddress() == address1) {\n                IERC20(address1).transferFrom(\n                    msg.sender,\n                    address(this),\n                    inputAmount\n                );\n                IERC20(address1).approve(address(pool1), inputAmount);\n                pool1.sellAssetOne{value: pool1.swapFee()}(inputAmount);\n            } else {\n                IERC20(address1).transferFrom(\n                    msg.sender,\n                    address(this),\n                    inputAmount\n                );\n                IERC20(address1).approve(address(pool1), inputAmount);\n                pool1.sellAssetTwo{value: pool1.swapFee()}(inputAmount);\n            }\n            //SWAP 2, routing token into output token\n            uint256 routingTokenInput = IERC20(routingToken).balanceOf(\n                address(this)\n            ) - startingBalance;\n            if (pool2.assetOneAddress() == address1) {\n                IERC20(routingToken).approve(address(pool2), routingTokenInput);\n                pool2.sellAssetOne{value: pool2.swapFee()}(routingTokenInput);\n            } else {\n                IERC20(routingToken).approve(address(pool2), routingTokenInput);\n                pool2.sellAssetTwo{value: pool2.swapFee()}(routingTokenInput);\n            }\n            uint256 address2Output = IERC20(address2).balanceOf(address(this)) -\n                startingBalance2;\n            IERC20(address2).transfer(msg.sender, address2Output);\n            // Unrequired fee\n            uint256 unrequiredFee = msg.value -\n                pool1.swapFee() -\n                pool2.swapFee(); // In case the msg.sender sent more value than it is required\n            (bool sent, ) = payable(msg.sender).call{value: unrequiredFee}(\"\");\n            require(sent, \"Failed to send Ether\");\n        } else {\n            // Assets cant be swapped directly nor routed\n            revert SwapRouter_tokensCantBeSwapped();\n        }\n    }\n\n    /**\n     * @notice Estimates the output amount for a swap from `address1` to `address2` given an `inputAmount` of `address1`.\n     * @dev Considers direct swaps and routed swaps through an intermediary token, utilizing PoolTracker for calculations.\n     * @param address1 The token being sold.\n     * @param address2 The token being bought.\n     * @param inputAmount The amount of `address1` tokens to swap.\n     * @return output The estimated amount of `address2` tokens to be received.\n     */\n    function getSwapAmount(\n        address address1,\n        address address2,\n        uint256 inputAmount\n    ) public view returns (uint256) {\n        uint256 output;\n        if (poolTracker.exists(address1, address2)) {\n            LiquidityPool pool = poolTracker.pairToPool(address1, address2);\n            output = pool.getSwapQuantity(address1, inputAmount);\n        } else if (poolTracker.tokenToRoute(address1, address2) != address(0)) {\n            address routingToken = poolTracker.tokenToRoute(address1, address2);\n            LiquidityPool pool1 = poolTracker.pairToPool(\n                address1,\n                routingToken\n            );\n            LiquidityPool pool2 = poolTracker.pairToPool(\n                address2,\n                routingToken\n            );\n            uint256 routingOutput = pool1.getSwapQuantity(\n                address1,\n                inputAmount\n            );\n            output = pool2.getSwapQuantity(routingToken, routingOutput);\n        } else {\n            // Assets cant be swapped directly nor routed\n            revert SwapRouter_tokensCantBeSwapped();\n        }\n        return output;\n    }\n\n    /**\n     * @dev Fallback function if address calls unexisting function, but contains msg.data\n     */\n    fallback() external payable {}\n\n    /**\n     * @dev Receive function if address calls unexisting function, without msg.data\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/Lending/Lending.sol": {
      "content": "// SPDX-License-Identifier:MIT\n\npragma solidity ^0.8.9;\n\n// OpenZeppelin's ERC20 interface for interactions with ERC20 tokens.\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\n\n// Custom errors for specific failure conditions.\nerror lending_outOfReserve();\nerror lending_addressNotAllowed();\nerror lending_reserveNotAvailable();\nerror lending_notEnoughTimePassed();\n\n/**\n * @title Lending\n * @dev Implements lending and yield farming functionalities for a specific ERC20 token.\n * This contract allows tokens to be lent out and borrowed, tracks yield farming activities,\n * and allows for the accumulation and withdrawal of yield based on predefined APY.\n */\ncontract Lending {\n    // The ERC20 token used for lending and borrowing.\n    IERC20 public token;\n\n    // Address of the owner contract.\n    address public ownerContract;\n\n    // Total amount of tokens lent out.\n    uint256 public amoutLended;\n\n    // Available reserve for borrowing.\n    uint256 public reserve;\n\n    // Annual Percentage Yield for borrowing.\n    uint256 public borrowingAPY;\n\n    // Total yield generated.\n    uint256 public yield;\n\n    // Yield already farmed.\n    uint256 public farmedYield;\n\n    // Mapping of addresses to their last yield farming timestamp.\n    mapping(address => uint256) public lastYieldFarmedTime;\n\n    // Mapping of addresses to the amount of yield they have taken.\n    mapping(address => uint256) public yieldTaken;\n\n    /**\n     * @dev Ensures that only the owner contract can call the modified function.\n     */\n    modifier onlyOwner() {\n        if (msg.sender != ownerContract) {\n            revert lending_addressNotAllowed();\n        }\n        _;\n    }\n\n    /**\n     * @param _token The ERC20 token address for lending and borrowing.\n     */\n    constructor(address _token) {\n        token = IERC20(_token);\n        ownerContract = msg.sender;\n    }\n\n    /**\n     * @notice Allows the owner to borrow tokens from the reserve.\n     * @param amount The amount of tokens to borrow.\n     */\n    function borrow(uint256 amount) public onlyOwner {\n        if (reserve - amount < 0) {\n            revert lending_outOfReserve();\n        }\n        token.transfer(msg.sender, amount);\n    }\n\n    /**\n     * @notice Allows the owner to lend tokens to the contract.\n     * @param amount The amount of tokens to lend.\n     */\n    function lend(uint256 amount) public onlyOwner {\n        token.transferFrom(msg.sender, address(this), amount);\n        reserve += amount;\n    }\n\n    /**\n     * @notice Sets the borrowing APY.\n     * @param newAPY The new APY value.\n     */\n    function setBorrowingAPY(uint256 newAPY) public onlyOwner {\n        borrowingAPY = newAPY;\n    }\n\n    /**\n     * @notice Checks if enough time has passed for a user to farm yield again.\n     * @param user The address of the user.\n     * @return bool True if enough time has passed, false otherwise.\n     */\n    function isTime(address user) public view returns (bool) {\n        lastYieldFarmedTime[user];\n        uint256 currentStamp = block.timestamp;\n        if ((lastYieldFarmedTime[user] + 1 days) < currentStamp) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Withdraws tokens from the reserve.\n     * This function allows the owner to withdraw tokens from the available reserve, reducing the reserve balance.\n     * @param amount The amount of tokens to withdraw from the reserve.\n     */\n    function withdraw(uint256 amount) public onlyOwner {\n        if (reserve - amount < 0) {\n            revert lending_reserveNotAvailable();\n        }\n        token.transfer(msg.sender, amount);\n        reserve -= amount;\n    }\n\n    /**\n     * @notice Calculates and returns the available yield for a user.\n     * This function updates the yield taken and farmed yield accordingly.\n     * @param user The address of the user farming yield.\n     * @param tokenAmount The amount of tokens used for calculating the user's share of the yield.\n     * @return uint256 The amount of yield available for the user.\n     */\n    function getYield(\n        address user,\n        uint256 tokenAmount\n    ) public onlyOwner returns (uint256) {\n        if (isTime(user) == false) {\n            revert lending_notEnoughTimePassed();\n        }\n        lastYieldFarmedTime[user] = block.timestamp; // Reentrancy guard\n        uint256 yieldSoFar = yieldTaken[user];\n        uint256 userLiquidity = (tokenAmount * 100) / amoutLended;\n        uint256 availableYield = ((yield -\n            ((yieldSoFar * 100) / userLiquidity)) * userLiquidity) / 100;\n\n        if (availableYield > yield - farmedYield) {\n            revert lending_notEnoughTimePassed(); // IN CASE THERE IS A LOT OF PEOPLE GETTING YIELD AT ONCE AND RATIOS GET CHANGED TOO MUCH\n        }\n        yieldTaken[msg.sender] += availableYield;\n        farmedYield += availableYield;\n        return availableYield;\n    }\n}\n"
    },
    "contracts/Lending/LendingTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n// Importing necessary contracts and interfaces\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./Lending.sol\";\n\n// Custom error definitions for specific failure conditions\nerror lendingTracker_addressNotAllowed();\nerror lendingTracker_poolNotAvailable();\nerror lendingTracker_amountTooHigh();\nerror lendingTracker_receiptDoesntExist();\n\n/**\n * @title LendingTracker\n * @dev Manages lending, borrowing, and collateral operations for a decentralized finance platform.\n * Utilizes external price feeds for valuation and includes functionality for yield farming.\n * This contract is responsible for tracking user interactions with lending pools and their collateralized positions.\n */\ncontract LendingTracker {\n    // Events for logging various actions within the contract\n    event userBorrowed(address user, address tokenAddress, uint256 tokenAmount);\n    event userLended(address user, address tokenAddress, uint256 tokenAmount);\n    event userWithdrawnLendedTokens(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event userStakedCollateral(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event userUnstakedCollateral(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event userReturnedBorrowedToken(\n        address user,\n        address tokenAddress,\n        uint256 receiptId,\n        uint256 tokenAmount,\n        uint256 interest\n    );\n    event userFarmedYield(\n        address user,\n        address tokenAddress,\n        uint256 tokenAmount\n    );\n    event collateralTerminated(address user);\n\n    // Maximum Loan-to-Value (LTV) ratio for borrowing against collateral\n    int256 ltv = 75;\n\n    // Owner of the contract, set at deployment\n    address owner;\n\n    // Constructor sets the deploying address as the owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Struct to hold lending pool and its associated price feed information\n    struct tokenPool {\n        Lending poolAddress; // ERC-20 Token address\n        address priceAddress; // Chainlink price feed\n    }\n\n    // Struct to track borrowing receipts for users\n    struct borrowReceipt {\n        address tokenAddress;\n        uint256 amount;\n        uint256 time;\n        uint256 apy;\n    }\n\n    // Mappings to track lending pools, user interactions, and collateral\n    mapping(address => tokenPool) public tokenToPool; // To find pool for specific ERC20 address\n\n    mapping(address => mapping(address => uint256)) public userLendedAmount; // Lended amout of specific token for user\n    mapping(address => address[]) public userLendedTokens; // All lended token addresses of user\n\n    mapping(address => mapping(address => uint256)) public collateral; // Collateral amount of specific token for user\n    mapping(address => address[]) public collateralTokens; // All collateralized token addresses of user\n\n    mapping(address => address[]) public borrowedTokens; // All borrowed token addresses of user\n    mapping(address => uint256) public borrowingId; // Current borrowing Id of the user, it increments with each borrow\n    mapping(address => mapping(address => uint256[])) public userBorrowReceipts; // All receipt ids for a certain token address of user\n    mapping(address => mapping(uint256 => borrowReceipt)) public borrowReceipts; // Id to receipt\n\n    /**\n     * @notice Adds a new token pool for lending and borrowing.\n     * @dev Deploys a new Lending contract for the token and registers it along with its price feed.\n     * @param tokenAddress Address of the token for the new lending pool.\n     * @param priceAddress Address of the Chainlink price feed for the token.\n     */\n    function addTokenPool(address tokenAddress, address priceAddress) public {\n        if (msg.sender != owner) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        Lending newPool = new Lending(tokenAddress);\n        tokenToPool[tokenAddress] = tokenPool(newPool, priceAddress);\n    }\n\n    /**\n     * @notice Changes the price feed for a given token.\n     * @dev Allows the contract owner to update the price feed address in case of changes or migration.\n     * @param tokenAddress Address of the token whose price feed is being updated.\n     * @param priceAddress New address of the Chainlink price feed.\n     */\n    function changePriceFeed(\n        address tokenAddress,\n        address priceAddress\n    ) public {\n        // Checks if address is allowed to call this\n        if (msg.sender != owner) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        // Checks if the pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        tokenToPool[tokenAddress].priceAddress = priceAddress;\n    }\n\n    /**\n     * @notice Updates the borrowing APY for a specified token pool.\n     * @param tokenAddress Address of the token whose lending pool APY is to be changed.\n     * @param newAPY The new annual percentage yield for borrowing.\n     */\n    function changeBorrowingAPY(address tokenAddress, uint256 newAPY) public {\n        if (msg.sender != owner) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        tokenToPool[tokenAddress].poolAddress.setBorrowingAPY(newAPY);\n    }\n\n    /**\n     * @notice Allows a user to borrow tokens from a specific lending pool.\n     * @dev The function checks for sufficient liquidity and adherence to the loan-to-value (LTV) ratio before permitting the borrow.\n     * Updates the user's borrow receipts to keep track of the borrowed amount and terms.\n     * @param tokenAddress The address of the token the user wishes to borrow.\n     * @param tokenAmount The amount of tokens the user wants to borrow.\n     */\n    function borrowToken(address tokenAddress, uint256 tokenAmount) public {\n        // Checks if the pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Liquidity treshold, if ltv is too high\n        if (liquidityTreshold(msg.sender, tokenAddress, tokenAmount) >= ltv) {\n            revert lendingTracker_amountTooHigh();\n        }\n        // Borrows from the pool contract\n        tokenToPool[tokenAddress].poolAddress.borrow(tokenAmount); // Checks if there is enough reserve\n\n        // Maps the token address if needed\n        if (newTokenChecker(borrowedTokens[msg.sender], tokenAddress) == true) {\n            borrowedTokens[msg.sender].push(tokenAddress);\n        }\n        // Adds funds to a mapping\n        userBorrowReceipts[msg.sender][tokenAddress].push(\n            borrowingId[msg.sender]\n        );\n        borrowReceipts[msg.sender][borrowingId[msg.sender]] = borrowReceipt(\n            tokenAddress,\n            tokenAmount,\n            block.timestamp,\n            tokenToPool[tokenAddress].poolAddress.borrowingAPY()\n        );\n\n        // Transfers tokens to user\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n        // User receipt Id\n        borrowingId[msg.sender] += 1;\n\n        // Event\n        emit userBorrowed(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Enables a user to lend tokens to a specific pool.\n     * @dev Transfers tokens from the user to the lending pool contract and updates the tracking of lent amounts.\n     * Requires token approval from the user to the LendingTracker contract.\n     * @param tokenAddress The address of the token being lent.\n     * @param tokenAmount The amount of tokens the user is lending.\n     */\n    function lendToken(address tokenAddress, uint256 tokenAmount) public {\n        // Checks if pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Transfer and approve tokens\n        IERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        IERC20(tokenAddress).approve(\n            address(tokenToPool[tokenAddress].poolAddress),\n            tokenAmount\n        );\n        // Maps the token address if needed\n        if (\n            newTokenChecker(userLendedTokens[msg.sender], tokenAddress) == true\n        ) {\n            userLendedTokens[msg.sender].push(tokenAddress);\n        }\n        // Add funds to mapping\n        userLendedAmount[msg.sender][tokenAddress] += tokenAmount;\n        tokenToPool[tokenAddress].poolAddress.lend(tokenAmount);\n\n        // Event\n        emit userLended(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Withdraws tokens previously lent to the lending pool by the user.\n     * @dev Ensures the user cannot withdraw more than they have lent. Adjusts the user's lent amount record accordingly.\n     * @param tokenAddress The address of the token to withdraw from the lending pool.\n     * @param tokenAmount The amount of tokens to withdraw.\n     */\n    function withdrawLendedToken(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public {\n        // Checks if pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Checks if there is enough tokens in the pool\n        if (userLendedAmount[msg.sender][tokenAddress] < tokenAmount) {\n            revert lendingTracker_amountTooHigh();\n        }\n        userLendedAmount[msg.sender][tokenAddress] -= tokenAmount;\n        tokenToPool[tokenAddress].poolAddress.withdraw(tokenAmount);\n        // Transfer tokens to user\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n\n        // Event\n        emit userWithdrawnLendedTokens(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Allows users to stake tokens as collateral for borrowing.\n     * @dev Transfers tokens from the user to this contract for collateralization. Updates the collateral tracking mappings.\n     * @param tokenAddress The address of the token being staked as collateral.\n     * @param tokenAmount The amount of the token to stake.\n     */\n    function stakeCollateral(address tokenAddress, uint256 tokenAmount) public {\n        // Checks if pool exists\n        if (address(tokenToPool[tokenAddress].poolAddress) == address(0)) {\n            revert lendingTracker_poolNotAvailable();\n        }\n        // Transfers tokens from user to the contract\n        IERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount\n        );\n        // Maps the token address if needed\n        if (\n            newTokenChecker(collateralTokens[msg.sender], tokenAddress) == true\n        ) {\n            collateralTokens[msg.sender].push(tokenAddress);\n        }\n        // Adds the amount to mapping\n        collateral[msg.sender][tokenAddress] += tokenAmount;\n\n        //Event\n        emit userStakedCollateral(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Permits users to withdraw their staked collateral, provided they have no outstanding loans.\n     * @dev Ensures that the withdrawal does not violate the loan-to-value (LTV) requirements.\n     * @param tokenAddress The address of the token to unstake.\n     * @param tokenAmount The amount of the token to unstake.\n     */\n    function unstakeCollateral(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public {\n        // Checks if amount is too high and if the user is borrowing any tokens\n        if (\n            collateral[msg.sender][tokenAddress] - tokenAmount < 0 &&\n            borrowedTokens[msg.sender].length > 0\n        ) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        // Decreases amount in mapping\n        collateral[msg.sender][tokenAddress] -= tokenAmount;\n        // Transfers the tokens to user\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n        // Maps the token address if needed\n        if (collateral[msg.sender][tokenAddress] == 0) {\n            for (uint256 i; i < collateralTokens[msg.sender].length; i++) {\n                if (collateralTokens[msg.sender][i] == tokenAddress) {\n                    delete collateralTokens[msg.sender][i];\n                }\n            }\n        }\n\n        //Event\n        emit userUnstakedCollateral(msg.sender, tokenAddress, tokenAmount);\n    }\n\n    /**\n     * @notice Computes the current loan-to-value (LTV) ratio for a user's borrowed funds against their staked collateral.\n     * @dev Used to determine if a user's borrowings are within permissible limits. Can also factor in an additional amount\n     * being borrowed or provided as collateral.\n     * @param user The address of the user.\n     * @param additionalTokenAddress Optionally, the address of a token being considered for borrowing/collateral.\n     * @param tokenAmount Optionally, the amount of the additional token being considered.\n     * @return The LTV ratio as a percentage.\n     */\n    function liquidityTreshold(\n        address user,\n        address additionalTokenAddress,\n        uint256 tokenAmount\n    ) public view returns (int) {\n        // It checks the price in USD if collaterall falls below borrowed amount in usd + the apy till date, the collateral get terminated\n        int collateralUSD;\n        int borrowedUSD;\n        // If we want to calculate ltv with additional funds\n        if (\n            tokenAmount != 0 &&\n            tokenToPool[additionalTokenAddress].priceAddress != address(0)\n        ) {\n            int conversion = usdConverter(\n                tokenToPool[additionalTokenAddress].priceAddress\n            );\n            collateralUSD += conversion * int(tokenAmount);\n        }\n        for (uint256 i; i < collateralTokens[user].length; i++) {\n            address tokenAddress = collateralTokens[user][i];\n            uint256 amountOfToken = collateral[user][tokenAddress];\n            // Get conversion to USD\n            int conversion = usdConverter(\n                tokenToPool[tokenAddress].priceAddress\n            );\n            collateralUSD += conversion * int(amountOfToken);\n        }\n        for (uint256 i; i < borrowedTokens[user].length; i++) {\n            address tokenAddress = borrowedTokens[user][i];\n            uint256[] storage receiptIds = userBorrowReceipts[user][\n                tokenAddress\n            ];\n            for (uint256 a; a < receiptIds.length; a++) {\n                uint256 receiptTIME = borrowReceipts[msg.sender][receiptIds[a]]\n                    .time;\n                uint256 receiptAMOUNT = borrowReceipts[msg.sender][\n                    receiptIds[a]\n                ].amount;\n                address receiptAddress = borrowReceipts[msg.sender][\n                    receiptIds[a]\n                ].tokenAddress;\n                uint256 receiptAPY = borrowReceipts[msg.sender][receiptIds[a]]\n                    .apy;\n                uint256 borrowInterest = (receiptAMOUNT *\n                    receiptTIME *\n                    receiptAPY) / (365 days * 100);\n                int conversion = usdConverter(\n                    tokenToPool[receiptAddress].priceAddress\n                );\n                borrowedUSD += conversion * int(borrowInterest + receiptAMOUNT);\n            }\n        }\n        return (borrowedUSD * 100) / collateralUSD;\n    }\n\n    /**\n     * @notice Initiates the liquidation of a user's collateral if their LTV ratio exceeds the maximum permitted value.\n     * @dev Meant to be called by an external mechanism (like a keeper) that monitors LTV ratios.\n     * @param userAddress The address of the user whose collateral is being liquidated.\n     */\n    function terminateCollateral(address userAddress) public {\n        // Check if the ltv is too high, if it is not reverts\n        if (liquidityTreshold(userAddress, address(0), 0) <= ltv) {\n            revert lendingTracker_addressNotAllowed();\n        }\n        // terminate user collateral and share it between the lenders\n        for (uint256 i; i < collateralTokens[userAddress].length; i++) {\n            collateral[msg.sender][collateralTokens[userAddress][i]] = 0;\n            delete collateralTokens[msg.sender][i];\n        }\n        // Add swap on uniswap router or swap between pools\n\n        // Event\n        emit collateralTerminated(userAddress);\n    }\n\n    /**\n     * @notice Converts the token amount to its USD equivalent using Chainlink price feeds.\n     * @dev Utility function to assist in calculating collateral values and loan amounts.\n     * @param priceAddress Address of the Chainlink price feed for the token.\n     * @return int The USD value of the token amount based on the latest price feed data.\n     */\n    function usdConverter(address priceAddress) public view returns (int) {\n        (, int answer, , , ) = AggregatorV3Interface(priceAddress)\n            .latestRoundData();\n        return answer;\n    }\n\n    /**\n     * @notice Checks if a new token is not already tracked by the user's token array.\n     * @dev Utility function to prevent duplicate entries in user token arrays.\n     * @param userTokens Array of token addresses the user has interacted with.\n     * @param token Address of the token to check.\n     * @return bool True if the token is not in the array, false otherwise.\n     */\n    function newTokenChecker(\n        address[] memory userTokens,\n        address token\n    ) public pure returns (bool) {\n        bool newToken = true;\n        for (uint256 i; i < userTokens.length; i++) {\n            if (token == userTokens[i]) {\n                newToken = false;\n            }\n        }\n        return newToken;\n    }\n\n    /**\n     * @notice Claims yield for the user based on the tokens they have lent to the pool.\n     * @dev Calculates the yield based on the amount lent and the time passed, then transfers the yield to the user.\n     * @param tokenAddress The address of the token for which yield is being claimed.\n     */\n    function getYield(address tokenAddress) public {\n        uint256 yield = tokenToPool[tokenAddress].poolAddress.getYield(\n            msg.sender,\n            userLendedAmount[msg.sender][tokenAddress]\n        );\n        IERC20(tokenAddress).transfer(msg.sender, yield);\n\n        // Event\n        emit userFarmedYield(msg.sender, tokenAddress, yield);\n    }\n\n    /**\n     * @notice Allows a user to return borrowed tokens along with any accrued interest.\n     * @dev Calculates interest based on the borrowing APY and time elapsed since the token was borrowed.\n     * @param id The unique identifier of the borrow receipt.\n     * @param tokenAmount The amount of the borrowed token being returned.\n     */\n    function returnBorrowedToken(uint256 id, uint256 tokenAmount) public {\n        if (borrowReceipts[msg.sender][id].amount == 0) {\n            revert lendingTracker_receiptDoesntExist();\n        }\n        if (borrowReceipts[msg.sender][id].amount - tokenAmount < 0) {\n            revert lendingTracker_amountTooHigh();\n        }\n        uint256 receiptAPY = borrowReceipts[msg.sender][id].apy;\n        uint256 receiptTIME = borrowReceipts[msg.sender][id].time;\n        address tokenAddress = borrowReceipts[msg.sender][id].tokenAddress;\n\n        uint256 borrowInterest = (tokenAmount * receiptTIME * receiptAPY) /\n            (365 days * 100);\n\n        IERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            tokenAmount + borrowInterest\n        );\n        borrowReceipts[msg.sender][id].amount -= tokenAmount;\n\n        // Event\n        emit userReturnedBorrowedToken(\n            msg.sender,\n            tokenAddress,\n            id,\n            tokenAmount,\n            borrowInterest\n        );\n    }\n}\n\n// Need to do:\n// Swap of tokens after termination of collateral(or what to do if not swapping)\n// If yield number gets too high(uint256), we open up a new pool with same stats\n// If we make new pool with same token and price address we need to restore lended amount for each person(refreshPool())\n"
    },
    "contracts/tests/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\nimport \"@chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol\";\n"
    },
    "contracts/Tokens/TestToken1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestToken1 is ERC20, Ownable {\n    constructor() ERC20(\"TestToken1\", \"TEST1\") {\n        _mint(msg.sender, 1000 * 10 ** 18);\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyOwner {\n        _burn(from, amount);\n    }\n}\n"
    },
    "contracts/Tokens/TestToken2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestToken2 is ERC20, Ownable {\n    constructor() ERC20(\"TestToken2\", \"TEST2\") {\n        _mint(msg.sender, 1000 * 10 ** 18);\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyOwner {\n        _burn(from, amount);\n    }\n}\n"
    },
    "contracts/Tokens/TestToken3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract TestToken3 is ERC20, Ownable {\n    constructor() ERC20(\"TestToken3\", \"TEST3\") {\n        _mint(msg.sender, 1000 * 10 ** 18);\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) public onlyOwner {\n        _burn(from, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}